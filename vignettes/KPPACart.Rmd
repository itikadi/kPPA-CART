---
title: "kPPA‑CART: Reproducible analysis & benchmarking"
author: "Fabian Bong & Tobias K. Karakach"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  BiocStyle::html_document:
    toc: true
    toc_float: true
    css: corrected.css
    number_sections: no
    df_print: paged
  pdf_document:
    toc: true
    number_sections: true
params:
  # Toggle which studies to run (TRUE = run, FALSE = skip)
  run_takemon: true
  run_tcga_brca: true
  run_aurora: true
  # Local paths (set to NULL to auto-download where supported)
  takemon_proteomics_path: NULL
  takemon_rnaseq_path: NULL
  aurora_rnaseq_geo: "GSE209998"
  aurora_methylation_geo: "GSE212375"
  tcga_project: "TCGA-BRCA"
  # kPPA‑CART hyperparameters (defaults mirror manuscript)
  kppa_t_dims: 30
  takemon_f_prot: 800
  takemon_f_rna: 500
  takemon_p_iters: 2000
  tcga_f: 350
  tcga_t_dims: 10
  tcga_p_iters: 5000
  tcga_bootstrap_reps: 30
  random_seed: 12345
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, fig.align='center')
set.seed(params$random_seed)
```

# Introduction to kPPA-CART
 Due to the heterogeneity of multi-omics data, exacting their maximum information potential remains a challenge. Whereas some solutions have been offered, most cannot overcome the large linear dynamic range associated with such data, while others require large biological effect sizes to produce meaningful models. kPPA-CART is a robust, easy-to-implement alternative. Using ground truth data, we demonstrate that kPPA-CART exhibits superiority in inferring biological significance from low-intensity (low-count) features and studies with small biological effect sizes.
This introductory vignette provides an overview of the steps of the workflow, installation, and source of the dataset used as example.

## More info & citation

The approach behind kPPA-CART and its application to several datasets (e.g. usage examples) was presented in the following article:

> Bong et al. (2025); Augmented kurtosis-based projection pursuit: a novel, advanced machine learning approach for multi-omics data analysis and integration; *Nucleic Acids Research*; doi: [10.1093/nar/gkaf844](https://doi.org/10.1093/nar/gkaf844).

Please, cite this article if you use kPPA-CART in your research.

# Requirements
## Species
kPPA-CART is agnostic to biological species from which -omics data derive.

## Overview
This workflow reproduces and extends key analyses from **kPPA‑CART** (kurtosis‑based Projection Pursuit augmented with CART/Random Forests) for multi‑omics integration and discovery.

- Data acquisition & preprocessing for Takemon mouse kidney (proteomics + RNA‑seq), TCGA‑BRCA (RNA‑seq + RPPA + 450k), and AURORA metastatic breast cancer cohorts (RNA‑seq + 450k).
- Benchmarking across joint‑dimensionality reduction methods with **silhouette** and **true‑positive recovery** under low‑variance and small‑effect regimes.
- End‑to‑end kPPA‑CART pipelines that mirror manuscript defaults (feature batches *f*, iterations *p*, latent dims *t*), balanced class handling, and bootstrap aggregation of feature importances.
- Publication‑ready visuals (embeddings, heatmaps, panels) and a 350‑gene BCa signature derivation + external validation.

## What goes in
kPPA‑CART takes as input high‑dimensional omics matrices, where **rows are features (genes, proteins, CpGs, phosphosites)** and **columns are samples (patients, animals, conditions)**. Multiple data modalities can be combined by stacking or concatenating standardized feature blocks. Optionally, phenotype annotations (e.g., age, subtype, survival) can be supplied for downstream validation but are not required for the embedding itself.

**Supported inputs:**
- RNA‑seq count matrices (raw or normalized)
- Proteomics intensity tables
- DNA methylation beta matrices
- Clinical/phenotypic covariates (for post‑hoc association)

## What comes out
From these inputs, kPPA‑CART produces a series of interpretable outputs:

1. **Latent embeddings**: Lower‑dimensional sample coordinates capturing kurtosis‑optimized structure in the data.
2. **Unsupervised clusters**: Subgroups of samples discovered in the embedding space, which can correspond to known subtypes or novel groupings.
3. **Feature importance profiles**: Ranked features (genes/proteins/CpGs) that drive separation between clusters, aggregated across bagged random forests.
4. **Signature panels**: Stable, reproducible gene/protein signatures (e.g., the 350‑gene breast cancer panel derived in the manuscript).
5. **Visualizations**: Scatterplots of embeddings, heatmaps of top features, silhouette plots for benchmarking, and survival curves for external validation.

> Notes
> 1) Some downloads require credentials (e.g., GDC) and may need manual staging. 2) The kPPA‑CART R package is assumed available; if not, see install snippet below.

```{r libs}
# Core
suppressPackageStartupMessages({
  library(tidyverse); library(data.table); library(Matrix); library(glue)
  library(parallel); library(future.apply)
  library(cluster); library(factoextra); library(Rtsne)
  library(randomForest); library(rpart); library(rpart.plot)
  library(ComplexHeatmap); library(circlize); library(pheatmap)
  library(scales); library(ggrepel); library(ggpubr)
})

# Omics IO / preprocessing
suppressPackageStartupMessages({
  library(edgeR); library(limma)
  # TCGA / GEO (optional)
  suppressWarnings({
    if (requireNamespace("TCGAbiolinks", quietly = TRUE)) library(TCGAbiolinks)
    if (requireNamespace("GEOquery", quietly = TRUE)) library(GEOquery)
    # methylation
    if (requireNamespace("minfi", quietly = TRUE)) library(minfi)
  })
})

# Competing methods for benchmarking (install as needed)
suppressWarnings({
  if (requireNamespace("MOFA2", quietly = TRUE)) library(MOFA2)
  if (requireNamespace("iClusterPlus", quietly = TRUE)) library(iClusterPlus)
  if (requireNamespace("NMF", quietly = TRUE)) library(NMF)
})

# kPPA‑CART package (install from GitHub if not present)
if (!requireNamespace("KPPACart", quietly = TRUE)) {
  message("KPPACart not found. Installing from GitHub (requires devtools)")
  if (requireNamespace("devtools", quietly = TRUE)) {
    devtools::install_github("FabianBong/KPPACart")
  }
}
if (requireNamespace("KPPACart", quietly = TRUE)) library(KPPACart)
```

## 1.1 Utility helpers

```{r helpers}
# Silhouette helper given dist matrix and cluster labels
silhouette_score <- function(x, labels){
  d <- dist(x)
  sil <- cluster::silhouette(as.integer(as.factor(labels)), d)
  mean(sil[,3])
}

# Low/high variance feature selectors (percent threshold)
select_by_variance <- function(mat, pct = 0.15, direction = c("low","high")){
  v <- matrixStats::rowVars(as.matrix(mat), na.rm = TRUE)
  direction <- match.arg(direction)
  n <- round(length(v) * pct)
  idx <- if (direction == "low") order(v, decreasing = FALSE)[seq_len(n)] else order(v, decreasing = TRUE)[seq_len(n)]
  mat[idx, , drop = FALSE]
}

# Balanced subsampling by class labels (for 2^k compatibility)
balanced_subsample <- function(labels, n_per_class){
  idx <- unlist(lapply(split(seq_along(labels), labels), function(ix){
    if (length(ix) < n_per_class) stop("A class has fewer samples than n_per_class")
    sample(ix, n_per_class)
  }))
  sort(idx)
}

# Heatmap wrapper
hm <- function(mat, ann = NULL, name = "z", top_anno = NULL){
  mat <- mat[stats::complete.cases(mat), , drop = FALSE]
  Heatmap(mat, name = name, show_row_names = FALSE, cluster_rows = TRUE, cluster_columns = TRUE,
          top_annotation = top_anno, column_split = ann, heatmap_legend_param=list(title = name))
}

# kPPA‑CART wrapper (unsupervised -> pseudo‑supervised RF feature importances)
run_kppacart <- function(X, f, p, t_dims, n_clusters = 4, rf_ntree = 500, seed = 1){
  set.seed(seed)
  # kPPA embedding
  kppa <- KPPACart::kppa_embed(t(X), t_dims = t_dims) # expects samples x features
  # unsupervised clustering on kPPA embeddings
  cl <- kmeans(kppa$Z, centers = n_clusters, nstart = 20)$cluster
  # feature bagging + RF importance across p iterations selecting f features each
  imp <- KPPACart::feature_bag_rf(X = X, clusters = cl, f = f, p = p, ntree = rf_ntree, seed = seed)
  list(embedding = kppa$Z, clusters = cl, importance = imp)
}
```

# 2. Data acquisition & preprocessing

## 2.1 Takemon mouse kidney (proteomics + RNA‑seq)

```{r takemon-load, eval=params$run_takemon}
# Placeholders: read from local CSV/TSV if provided, else expect user‑staged matrices
prot <- NULL; rna <- NULL
if (!is.null(params$takemon_proteomics_path)) {
  prot <- fread(params$takemon_proteomics_path) %>% as.data.frame()
}
if (!is.null(params$takemon_rnaseq_path)) {
  rna <- fread(params$takemon_rnaseq_path) %>% as.data.frame()
}
# Expect rows = features, cols = samples; create mock phenotype (age, sex) if available
# phen <- readr::read_csv("path/to/takemon_pheno.csv")

# Basic preprocessing templates
prep_proteomics <- function(mat){
  mat <- as.matrix(mat)
  mat <- log2(mat + 1)
  mat <- limma::normalizeBetweenArrays(mat, method = "quantile")
  mat
}
prep_rnaseq <- function(counts){
  dge <- DGEList(counts = counts)
  keep <- filterByExpr(dge)
  dge <- dge[keep,, keep.lib.sizes = FALSE]
  dge <- calcNormFactors(dge, method = "TMM")
  v <- voom(dge)$E
  v
}
```

## 2.2 TCGA‑BRCA (RNA‑seq, RPPA, 450k)

```{r tcga-load, eval=params$run_tcga_brca}
if (requireNamespace("TCGAbiolinks", quietly = TRUE)) {
  # RNA‑seq (harmonized counts)
  # query <- GDCquery(project = params$tcga_project, data.category = "Transcriptome Profiling",
  #                   data.type = "Gene Expression Quantification", workflow.type = "HTSeq - Counts")
  # GDCdownload(query); data <- GDCprepare(query)
  # tcga_counts <- assay(data)
  # PAM50 subtypes via genefu if desired
}
```

## 2.3 AURORA (RNA‑seq + 450k from GEO)

```{r aurora-load, eval=params$run_aurora}
if (requireNamespace("GEOquery", quietly = TRUE)) {
  # RNA‑seq counts
  # gse_rna <- getGEO(params$aurora_rnaseq_geo, GSEMatrix = TRUE)
  # aurora_counts <- exprs(gse_rna[[1]])
  # DNA methylation idat processing (requires idat files; often manual)
  # gse_met <- getGEO(params$aurora_methylation_geo, GSEMatrix = TRUE)
}
```

# 3. Benchmarking experiments

## 3.1 Low‑variance vs high‑variance subsets (Takemon)

```{r takemon-benchmark, eval=params$run_takemon}
# Assume `prot_v` and `rna_v` are processed matrices (features x samples)
# prot_v <- prep_proteomics(prot)
# rna_v  <- prep_rnaseq(rna)

# Example grid
low_pcts  <- c(.03,.05,.10,.13,.15,.18,.20,.25,.30)
high_pcts <- c(.03,.05,.08,.10,.12,.15,.18,.20)

# Placeholder matrices to store silhouette across methods
# Implement calls to PCA/MOFA/iCluster/IntNMF/MCIA/IPCA/JIVE/tICA as available
# For brevity, we illustrate PCA vs kPPA‑CART; extend similarly for others

sil_low  <- data.frame(pct = low_pcts, PCA = NA_real_, kPPA_CART = NA_real_)
sil_high <- data.frame(pct = high_pcts, PCA = NA_real_, kPPA_CART = NA_real_)

# Pseudocode (uncomment when data available)
# for (i in seq_along(low_pcts)){
#   Xlow <- select_by_variance(prot_v, pct = low_pcts[i], direction = "low")
#   pca  <- prcomp(t(Xlow), scale. = TRUE)
#   cl_p <- kmeans(pca$x[,1:2], centers = 4, nstart = 20)$cluster
#   sil_low$PCA[i] <- silhouette_score(pca$x[,1:2], cl_p)
#   kfit <- run_kppacart(Xlow, f = params$takemon_f_prot, p = params$takemon_p_iters,
#                        t_dims = params$kppa_t_dims, n_clusters = 4, seed = params$random_seed)
#   sil_low$kPPA_CART[i] <- silhouette_score(kfit$embedding, kfit$clusters)
# }

# ggplot(sil_low, aes(pct*100)) + geom_line(aes(y=PCA)) + geom_line(aes(y=kPPA_CART)) +
#   labs(x = "% least‑variable features", y = "Mean silhouette")
```

## 3.2 Effect‑size simulations & TPR recovery

```{r effect-sim, eval=params$run_takemon}
# Simulate perturbations on a subset of features and compare TPR across methods
# See manuscript for effect sizes: 0.1,0.3,0.5,0.7,0.9,1.1,1.4,2.0,3.0,5.0
# Implement your simulation here and compute true‑positive recovery by tracking known perturbed features.
```

# 4. Takemon integrative analysis (RNA‑seq + Proteomics)

```{r takemon-integrative, eval=params$run_takemon}
# X_int <- rbind(scale(prot_v), scale(rna_v))
# kfit  <- run_kppacart(X_int, f = params$takemon_f_prot, p = params$takemon_p_iters,
#                       t_dims = params$kppa_t_dims, n_clusters = 4, seed = params$random_seed)
# # Top features by RF importance
# top_idx <- order(kfit$importance$importance, decreasing = TRUE)[1:40]
# top_feats <- rownames(X_int)[top_idx]
# hm(X_int[top_feats, ])
```

# 5. TCGA‑BRCA subtype modeling

## 5.1 Preprocessing & class balancing

```{r tcga-pre, eval=params$run_tcga_brca}
# tcga_v <- prep_rnaseq(tcga_counts)
# pam50_labels <- readr::read_csv("path/to/pam50_labels.csv")$subtype
# # Combine Normal‑like + LumA per manuscript rationale
# pam50_bal <- pam50_labels
# pam50_bal[pam50_bal %in% c("Normal-like","LumA")] <- "Normal_LumA"
# lbls <- factor(pam50_bal, levels = c("Basal","Her2","LumB","Normal_LumA"))
# n_per <- min(table(lbls))
# idx  <- balanced_subsample(lbls, n_per_class = n_per)
# Xb   <- tcga_v[, idx]
# yb   <- lbls[idx]
```

## 5.2 PCA vs kPPA‑CART embeddings

```{r tcga-embed, eval=params$run_tcga_brca}
# pca <- prcomp(t(Xb), scale. = TRUE)
# autoplot <- ggplot2::autoplot
# # PCA plot (if ggfortify installed)
# # autoplot(pca, data = data.frame(subtype = yb), colour = 'subtype')

# kfit <- run_kppacart(Xb, f = params$tcga_f, p = 1000, t_dims = params$tcga_t_dims, n_clusters = 4)
# emb  <- as.data.frame(kfit$embedding) %>% mutate(subtype = yb)
# ggplot(emb, aes(V1, V2, color = subtype)) + geom_point() + labs(title = "kPPA‑CART (TCGA‑BRCA)")
```

## 5.3 Bootstrap aggregation to derive 350‑gene signature

```{r tcga-bootstrap, eval=params$run_tcga_brca}
# reps <- params$tcga_bootstrap_reps
# feats_list <- vector("list", reps)
# for (r in seq_len(reps)){
#   idx <- balanced_subsample(lbls, n_per_class = n_per)
#   Xr  <- tcga_v[, idx]
#   kfr <- run_kppacart(Xr, f = params$tcga_f, p = params$tcga_p_iters, t_dims = params$tcga_t_dims, n_clusters = 4, seed = r)
#   feats_list[[r]] <- data.frame(feature = rownames(Xr), imp = kfr$importance$importance)
# }
# sig <- feats_list %>% bind_rows() %>% group_by(feature) %>% summarise(mean_imp = mean(imp, na.rm=TRUE)) %>% arrange(desc(mean_imp)) %>% slice_head(n = 350)
# write.csv(sig, "tcga_kPPA_CART_350_signature.csv", row.names = FALSE)
```

# 6. External validation on AURORA & survival association

```{r aurora-validate, eval=params$run_aurora}
# Intersect signature with AURORA genes
# common <- intersect(sig$feature, rownames(aurora_counts))
# aurora_v <- prep_rnaseq(aurora_counts[common, ])
# hm(aurora_v)

# Survival analysis requires clinical survival data (time, event). If available:
# library(survival); library(survminer)
# fit <- survfit(Surv(time, event) ~ high_low_group, data = clin)
# ggsurvplot(fit)
```

# 7. Integrated RNA‑seq + 450k in AURORA (TMB‑aware)

```{r aurora-integrative, eval=params$run_aurora}
# If methylation beta matrix available as met_beta (features x samples):
# X_int <- rbind(scale(aurora_v), scale(met_beta))
# k
